package org.opentestsystem.ap.itemimport.mapper;

import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.opentestsystem.ap.common.model.AbstractItem;
import org.opentestsystem.ap.common.model.AssessmentItem;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemAudioResource;
import org.opentestsystem.ap.common.model.ItemCcAudioAssociation;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.model.ItemMetadata;
import org.opentestsystem.ap.common.model.glossary.GlossaryConstants;
import org.opentestsystem.ap.common.model.glossary.GlossaryDialect;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguage;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguages;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.common.saaif.wordlist.HtmlType;
import org.opentestsystem.ap.common.saaif.wordlist.WordlistreleaseType;
import org.opentestsystem.ap.itemimport.model.IatAudio;
import org.opentestsystem.ap.itemimport.model.IatImage;
import org.opentestsystem.ap.itemimport.model.IatMappingResult;
import org.opentestsystem.ap.itemimport.model.ItemProps;
import org.opentestsystem.ap.itemimport.util.ImportFileUtil;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;


public abstract class IatModelMapper {
    private final int PIXEL_TO_EM_CONVERSION_RATE = 16;


    private static final Map<String, String> scoreEngineMap = new HashMap<>();


    static {
        scoreEngineMap.put("Automatic with Machine Rubric", "AutomaticWithRubric");
    }

    abstract Item mapContent(Item item,
                             ItemRelease release,
                             ItemContext itemContext,
                             String itemSourceFullPath);

    public final Item mapSaaifToIATModel(ItemProps itemProps,
                                         Item item,
                                         ItemRelease release,
                                         SmarterAppMetadata metadata,
                                         WordlistreleaseType wordListRelease,
                                         String wordlistFullPath,
                                         ItemContext itemContext,
                                         String itemDirFullPath) {
        if (null != wordListRelease) {
            item = mapWordlistToGlossaryTerms(item, itemContext, wordListRelease, wordlistFullPath);
        }
        item = mapContent(item, release, itemContext, itemDirFullPath);
        item = mapMetadata(item, metadata);
        item = mapAssociatedPassage(item, itemProps);
        item = mapTutorial(item, itemProps);
        return item;
    }

    /**
     * Main rich text mapping function used in non-stimulus items.
     * TTS is processed first since it uses the ItemRelease.Item.Content.ApipAccessibility static object
     *
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapRichTextContent(String content,
                                        ItemRelease.Item.Content.ApipAccessibility apipAccessibility,
                                        IatMappingResult result) {
        String iatContent = processTTSTags(content, apipAccessibility);
        result.setContent(processCommonTags(iatContent, result));
        return result;
    }

    /**
     * Main rich text mapping function used ONLY in stimulus items
     * TTS is processed first since it uses the ItemRelease.Passage.Content.ApipAccessibility static object
     *
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapRichTextContent(String content,
                                        ItemRelease.Passage.Content.ApipAccessibility apipAccessibility,
                                        IatMappingResult result) {
        String iatContent = processTTSTags(content, apipAccessibility);
        result.setContent(processCommonTags(iatContent, result));
        return result;
    }

    /**
     * Process common tags to both ItemRelease.Item and ItemRelease.Passage resources
     * @param content
     * @param result
     * @return
     */
    private String processCommonTags(String content, IatMappingResult result) {
        String iatContent = processGlossaryTags(content);
        iatContent = processImageTags(iatContent, result);
        iatContent = processAudioTags(iatContent, result);
        iatContent = processAnchorTags(iatContent, result);
        iatContent = processTableTags(iatContent);
        iatContent = processListTags(iatContent);
        iatContent = processHiddenDivTags(iatContent);

        return iatContent;
    }

    /**
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapQtiContentForChoiceInteraction(ItemRelease.Item.Content content,
                                                       IatMappingResult result) {
        final Document doc = Jsoup.parse(content.getQti().getValue(), "", Parser.xmlParser());

        doc.getElementsByTag("itemBody").forEach(itemBody -> {
            String qtiPrompt = itemBody.getElementsByTag("p").first().html();
            result.setContent(mapRichTextContent(qtiPrompt, content.getApipAccessibility(), result).getContent());

            for (Element choiceInteraction : itemBody.getElementsByTag("choiceInteraction")) {
                String responseId = choiceInteraction.attr("responseIdentifier");
                String prompt = choiceInteraction.getElementsByTag("prompt").first().html();

                if (responseId.equals("EBSR1")) {
                    result.setPartAPrompt(mapRichTextContent(prompt, content.getApipAccessibility(), result).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().html();
                        result.getPartAOptions().add(
                                mapRichTextContent(sChoiceText, content.getApipAccessibility(), result).getContent());
                    }
                } else if (responseId.equals("EBSR2")) {
                    result.setPartBPrompt(mapRichTextContent(prompt, content.getApipAccessibility(), result).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().html();
                        result.getPartBOptions().add(
                                mapRichTextContent(sChoiceText, content.getApipAccessibility(), result).getContent());
                    }
                }
            }
        });

        return result;
    }

    /**
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapQtiContentForMatchInteraction(ItemRelease.Item.Content content,
                                                      String itemId,
                                                      String itemSourceFullPath,
                                                      IatMappingResult result) {
        final Document doc = Jsoup.parse(content.getQti().getValue(), "", Parser.xmlParser());
        result.setContent(mapRichTextContent(content.getStem(), content.getApipAccessibility(), result).getContent());

        result.getCells().clear();
        result.getHeaders().clear();
        doc.getElementsByTag("simpleMatchSet").forEach(sms -> {
            sms.getElementsByTag("simpleAssociableChoice").forEach(sac -> {
                if (StringUtils.isNumeric(sac.attr("identifier"))) {
                    result.getCells().add(
                            mapRichTextContent(sac.html(), content.getApipAccessibility(), result).getContent());
                } else {
                    result.getHeaders().add(
                            mapRichTextContent(sac.html(), content.getApipAccessibility(), result).getContent());
                }
            });
        });

        result.setCorrectResponses(getCorrectResponsesFromQrx(itemId, itemSourceFullPath, "RESPONSE"));

        return result;
    }

    /**
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapTableInteractionContent(ItemRelease.Item.Content content,
                                                IatMappingResult result) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        doc.childNodes().forEach(element -> {
            if (element.nodeName().equals("p")) {
                prompt.append(element.outerHtml());
            }
        });
        result.setContent(mapRichTextContent(prompt.toString(), content.getApipAccessibility(), result).getContent());

        Elements tableItem = doc.getElementsByClass("tableItem");
        if (tableItem.size() == 1) {
            Element tiTable = tableItem.get(0);

            result.getHeaders().clear();
            tiTable.getElementsByTag("thead").forEach(thead -> {
                thead.getElementsByTag("th").forEach(th -> {
                    result.getHeaders().add(
                            mapRichTextContent(th.html(), content.getApipAccessibility(), result).getContent());
                });
            });

            result.getRows().clear();
            tiTable.getElementsByTag("tbody").forEach(tbody -> {
                tbody.getElementsByTag("tr").forEach(tr -> {
                    List<String> values = new ArrayList<>();
                    tr.getElementsByTag("td").forEach(td -> {
                        values.add(
                                mapRichTextContent(td.html(), content.getApipAccessibility(), result).getContent());
                    });
                    result.getRows().add(values);
                });
            });
        }

        return result;
    }

    /**
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapHtqsContent(ItemRelease.Item.Content content,
                                    IatMappingResult result) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        StringBuilder interText = new StringBuilder();

        Boolean interTextStarted = false;
        for (Element p : doc.getElementsByTag("p")) {
            if (p.getElementsByClass("interaction selectable").size() == 0 && !interTextStarted) {
                prompt.append(p.outerHtml());
            } else {
                interTextStarted = true;
                interText.append(convertInteractiveTagsToIat(p.outerHtml()));
            }
        }

        result.setContent(mapRichTextContent(prompt.toString(), content.getApipAccessibility(), result).getContent());
        result.setInteractiveText(mapRichTextContent(interText.toString(), content.getApipAccessibility(), result).getContent());

        return result;
    }

    /**
     * @param content
     * @param result
     * @return
     */
    IatMappingResult mapHtqoContent(ItemRelease.Item.Content content,
                                    IatMappingResult result) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        for (Element p : doc.getElementsByTag("p")) {
            prompt.append(p.outerHtml());
        }
        result.setContent(mapRichTextContent(prompt.toString(), content.getApipAccessibility(), result).getContent());

        AtomicInteger index = new AtomicInteger(0);
        doc.getElementsByTag("li").forEach(li -> {
            result.getOrderableStrings().add(
                    mapRichTextContent(li.html(), content.getApipAccessibility(), result).getContent());
            result.getOrderableStringsCorrectOrder().add(index.getAndIncrement());
        });

        return result;
    }

    /**
     * @param smarterAppMetadata
     * @return
     */
    ItemMetadata mapItemMetadata(SmarterAppMetadata smarterAppMetadata) {
        // TODO: Validate each metadata value is compatible with IAT
        ItemMetadata itemMetadata = new ItemMetadata();


        itemMetadata.setAccessibilityLanguageComplexity(defaultString(smarterAppMetadata.getAccessibilityLanguageComplexity()));
        itemMetadata.setAlgebraDescriptor1(defaultString(smarterAppMetadata.getAlgebraDescriptor1()));
        itemMetadata.setAlgebraDescriptor2(defaultString(smarterAppMetadata.getAlgebraDescriptor2()));
        itemMetadata.setAllowCalculator(mapYandNtoYesandNo(smarterAppMetadata.getAllowCalculator()));
        itemMetadata.setClaim2Category(mapClaim2Category(smarterAppMetadata.getClaim2Category()));
        itemMetadata.setClaim2SubCategory(defaultString(smarterAppMetadata.getClaim2SubCategory()));
        itemMetadata.setContentTaskModel(defaultString(smarterAppMetadata.getContentTaskModel()));
        itemMetadata.setCopyrightHolder(defaultString(smarterAppMetadata.getCopyrightHolder()));
        itemMetadata.setCopyrightHolderOther(defaultString(smarterAppMetadata.getCopyrightHolderOther()));
        itemMetadata.setDepthOfKnowledge(defaultString(smarterAppMetadata.getDepthOfKnowledge()));
        itemMetadata.setIntendedGrade(defaultString(smarterAppMetadata.getIntendedGrade()));
        itemMetadata.setLanguageFeatures(defaultString(smarterAppMetadata.getLanguageFeatures()));
        itemMetadata.setMaxGrade(defaultString(smarterAppMetadata.getMaximumGrade()));
        itemMetadata.setMaximumPoints(defaultString(smarterAppMetadata.getMaximumNumberOfPoints()));
        itemMetadata.setMeaningPurpose(defaultString(smarterAppMetadata.getMeaningPurpose()));
        itemMetadata.setMinGrade(defaultString(smarterAppMetadata.getMinimumGrade()));

        itemMetadata.setPerformanceTask(
            mapYandNtoYesandNo(smarterAppMetadata.getPerformanceTaskComponentItem()));

        itemMetadata.setPerformanceTaskPosition(defaultString(smarterAppMetadata.getPtSequence()));
        itemMetadata.setPrimaryClaim(defaultString(smarterAppMetadata.getPrimaryClaim()));
        itemMetadata.setPrimaryCommonCoreStandard(defaultString(smarterAppMetadata.getPrimaryCommonCoreStandard()));
        itemMetadata.setPrimaryContentDomain(defaultString(smarterAppMetadata.getPrimaryContentDomain()));
        itemMetadata.setQuaternaryClaim(defaultString(smarterAppMetadata.getQuaternaryClaim()));
        itemMetadata.setQuaternaryCommonCoreStandard(defaultString(smarterAppMetadata.getQuaternaryCommonCoreStandard()));
        itemMetadata.setReadabilityFleschKincaid(defaultString(smarterAppMetadata.getReadabilityFleschKincaid()));
        itemMetadata.setReadabilityLexile(defaultString(smarterAppMetadata.getReadabilityLexile()));

        itemMetadata.setScorePoints(
            defaultString(smarterAppMetadata.getScorePoints())
                .replace("\"", "")
                .replace(" ", "")
                .replace(",", ", ")
        );

        itemMetadata.setScoringEngine(
            MapUtils.getString(
                scoreEngineMap, smarterAppMetadata.getScoringEngine(), defaultString(smarterAppMetadata.getScoringEngine())
            )
        );

        itemMetadata.setSecondaryClaim(defaultString(smarterAppMetadata.getSecondaryClaim()));
        itemMetadata.setSecondaryCommonCoreStandard(defaultString(smarterAppMetadata.getSecondaryCommonCoreStandard()));
        itemMetadata.setSecondaryContentDomain(defaultString(smarterAppMetadata.getSecondaryContentDomain()));
        itemMetadata.setSpecificationsVersion(defaultString(smarterAppMetadata.getSpecificationsVersion()));
        itemMetadata.setStimulusFormat(defaultString(smarterAppMetadata.getStimulusGenre()));
        itemMetadata.setStimulusLength(defaultString(smarterAppMetadata.getStimulusLength()));
        itemMetadata.setStimulusLiteraryKnowledgeDemands(defaultString(smarterAppMetadata.getStimulusLiteraryKnowledgeDemands()));
        itemMetadata.setStimulusLiteraryCategory(defaultString(smarterAppMetadata.getStimulusLiteraryNonFiction()));
        itemMetadata.setStimulusName(defaultString(smarterAppMetadata.getStimulusName()));
        itemMetadata.setStructure(defaultString(smarterAppMetadata.getStructure()));

        itemMetadata.setSubject(
            mapIatSubject(smarterAppMetadata.getSubject()));

        itemMetadata.setTertiaryClaim(defaultString(smarterAppMetadata.getTertiaryClaim()));
        itemMetadata.setTertiaryCommonCoreStandard(defaultString(smarterAppMetadata.getTertiaryCommonCoreStandard()));
        itemMetadata.setTertiaryContentDomain(defaultString(smarterAppMetadata.getTertiaryContentDomain()));
        itemMetadata.setTestCategory(defaultString(smarterAppMetadata.getTestCategory()));
        itemMetadata.setVersion(defaultString(smarterAppMetadata.getVersion()));
        itemMetadata.setWordCount(defaultString(smarterAppMetadata.getWordCount()));

        itemMetadata.setWritingPurpose(
            mapIatWritingPurpose(smarterAppMetadata.getPtWritingType()));

        itemMetadata.setItemAuthor(smarterAppMetadata.getItemAuthorIdentifier()
            .stream().collect(Collectors.joining(",")));

        itemMetadata.setPrimaryMathematicalPractice(smarterAppMetadata.getMathematicalPractice()
            .stream().collect(Collectors.joining(",")));

        return itemMetadata;
    }

    /**
     * @param item
     * @param metadata
     * @return
     */
    Item mapMetadata(Item item, SmarterAppMetadata metadata) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        assessmentItem.getCore().setMetadata(mapItemMetadata(metadata));
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapAssociatedPassage(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportAssociatedPassage())) {
            assessmentItem.getCore().setStimulusId(itemProps.getImportAssociatedPassage());
        }
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapTutorial(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportTutorialId())) {
            assessmentItem.getCore().setTutorialId(itemProps.getTutorialId());
        }
        return assessmentItem;
    }

    /**
     * Process attachments for non-Stimulus resources
     * @param content
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processAttachments(ItemRelease.Item.Content content,
                            AbstractItem item,
                            String itemSourceFullPath,
                            String itemDestinationFullPath) {
        if (content.getAttachmentlist() != null && content.getLanguage().equals("ENU")) {
            for (ItemRelease.Item.Content.Attachmentlist.Attachment attachment :
                content.getAttachmentlist().getAttachment()) {
                if (attachment.getType().equals("ASL")) {
                    processItemAslAttachments(attachment, item, itemSourceFullPath, itemDestinationFullPath);
                } else if (attachment.getType().equals("BRF") || attachment.getType().equals("PRN")) {
                    processBrailleAttachment(attachment.getFile(), item, itemSourceFullPath, itemDestinationFullPath);
                }
            }
        }
    }

    /**
     * Process attachments for Stimulus resources
     * @param content
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processAttachments(ItemRelease.Passage.Content content,
                            AbstractItem item,
                            String itemSourceFullPath,
                            String itemDestinationFullPath) {
        if (content.getAttachmentlist() != null && content.getLanguage().equals("ENU")) {
            for (ItemRelease.Passage.Content.Attachmentlist.Attachment attachment :
                    content.getAttachmentlist().getAttachment()) {
                if (attachment.getType().equals("ASL")) {
                    processStimuliAslAttachments(attachment, item, itemSourceFullPath, itemDestinationFullPath);
                } else if (attachment.getType().equals("BRF") || attachment.getType().equals("PRN")) {
                    processBrailleAttachment(attachment.getFile(), item, itemSourceFullPath, itemDestinationFullPath);
                }
            }
        }
    }

    /**
     * Process Asl Attachments for non-stimulus items.
     * ItemRelease.Item.Content.Attachmentlist.Attachment
     * @param attachment
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    private void processItemAslAttachments(ItemRelease.Item.Content.Attachmentlist.Attachment attachment,
                                           AbstractItem item,
                                           String itemSourceFullPath,
                                           String itemDestinationFullPath) {
        if (attachment.getSource() != null) {
            attachment.getSource().forEach(attach -> {
                item.getAsl().getAttachments().add(newItemAttachment(attach.getSrc(), itemSourceFullPath, itemDestinationFullPath));
            });
        } else {
            item.getAsl().getAttachments().add(newItemAttachment(attachment.getFile(), itemSourceFullPath, itemDestinationFullPath));
        }
    }

    /**
     * Process Asl Attachments for stimulus items.
     * ItemRelease.Passage.Content.Attachmentlist.Attachment
     * @param attachment
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    private void processStimuliAslAttachments(ItemRelease.Passage.Content.Attachmentlist.Attachment attachment,
                                       AbstractItem item,
                                       String itemSourceFullPath,
                                       String itemDestinationFullPath) {
        if (attachment.getSource() != null) {
           attachment.getSource().forEach(attach -> {
               item.getAsl().getAttachments().add(newItemAttachment(attach.getSrc(), itemSourceFullPath, itemDestinationFullPath));
           });
        } else {
            item.getAsl().getAttachments().add(newItemAttachment(attachment.getFile(), itemSourceFullPath, itemDestinationFullPath));
        }
    }

    /**
     * Process Braille attachments for all item types
     * @param fileName
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    private void processBrailleAttachment(String fileName,
                                      AbstractItem item,
                                      String itemSourceFullPath,
                                      String itemDestinationFullPath) {
        item.getBraille().getAttachments().add(newItemAttachment(fileName, itemSourceFullPath, itemDestinationFullPath));
    }

    /**
     * Create a new IAT Attachment and attempt to copy file to Item local directory.
     * @param fileName
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     * @return
     */
    private Attachment newItemAttachment(String fileName,
                                            String itemSourceFullPath,
                                            String itemDestinationFullPath) {
        ImportFileUtil.copyFile(itemSourceFullPath + "/" + fileName,
                itemDestinationFullPath + "/" + fileName);
        return createAttachment(fileName);
    }

    /**
     * Process Audio Resources for all item types.
     * @param mappingResult
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processAudioResources(IatMappingResult mappingResult,
                               AbstractItem item,
                               String itemSourceFullPath,
                               String itemDestinationFullPath) {
        //Process Audio Resources
        mappingResult.getAudioSources().forEach(audio -> {
            item.getAudio().getAudioResources().add(createItemAudioResource(audio, audio.getAudioId()));
            audio.getSources().forEach(source -> {
                ImportFileUtil.copyFile(itemSourceFullPath + "/" + source,
                    itemDestinationFullPath + "/" + source);
            });
            if (StringUtils.isNotBlank(audio.getTrack())) {
                item.getCc().getAttachments().add(createAttachment(audio.getTrack()));
                item.getCc().getItemCcAudioAssociations().add(createItemCCAudioAssociation(audio.getTrack(), audio.getAudioId()));
                ImportFileUtil.copyFile(itemSourceFullPath + "/" + audio.getTrack(),
                    itemDestinationFullPath + "/" + audio.getTrack());
            }
        });
    }

    /**
     * Process Image Resources for all item types.
     * @param mappingResult
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processImageResources(IatMappingResult mappingResult,
                               AbstractItem item,
                               String itemSourceFullPath,
                               String itemDestinationFullPath) {
        mappingResult.getImageSources().forEach(image -> {
            //int imageId = resourceId.getAndIncrement();
            item.getImages().getImageResources().add(createItemImageResource(image.getSource(), image.getImageId()));
            ImportFileUtil.copyFile(itemSourceFullPath + "/" + image.getSource(),
                itemDestinationFullPath + "/" + image.getSource());
        });
    }

    /**
     * Maps a WordlistReleaseType to GlossaryTerm
     * @param item
     * @param itemContext
     * @param wordlistreleaseType
     * @param wordListFullPath
     * @return
     */
    public Item mapWordlistToGlossaryTerms(Item item,
                                           ItemContext itemContext,
                                           WordlistreleaseType wordlistreleaseType,
                                           String wordListFullPath) {
        item.getGlossary().getTerms().clear();

        wordlistreleaseType.getItem().getKeywordList().getKeyword().forEach(keyword -> {
            GlossaryTerm glossaryTerm =
                    newGlossaryTerm(Integer.toString(keyword.getIndex()), keyword.getText());

            glossaryTerm.setLanguages(getIatGlossaryLanguages(keyword.getHtml(), itemContext, wordListFullPath));

            item.getGlossary().getTerms().add(glossaryTerm);
        });

        return item;
    }


    /**
     * Helper to create a new GlossaryTerm
     * @param termId
     * @param term
     * @return
     */
    private GlossaryTerm newGlossaryTerm(String termId,
                                         String term) {
        GlossaryTerm glossaryTerm = new GlossaryTerm();
        glossaryTerm.setId(termId);
        glossaryTerm.setTerm(term);
        return glossaryTerm;
    }

    /**
     * Maps a List<HtmlType> to a GlossaryLanguages object
     * @param htmlTypes
     * @param itemContext
     * @param wordlistFullPath
     * @return
     */
    private GlossaryLanguages getIatGlossaryLanguages(List<HtmlType> htmlTypes,
                                                      ItemContext itemContext,
                                                      String wordlistFullPath) {
        GlossaryLanguages glossaryLanguages = new GlossaryLanguages();
        htmlTypes.forEach(htmlType -> {
            if (htmlType.getListType().toLowerCase().contains("glossary")) {
                setDialectsOnLanguage(glossaryLanguages, itemContext, htmlType, wordlistFullPath);
            }
        });
        checkForDefaultDialects(glossaryLanguages);

        return glossaryLanguages;
    }

    /**
     * Sets List<Dialect> for all languages found on import source file
     * @param glossaryLanguages
     * @param itemContext
     * @param html
     * @param wordlistFullPath
     */
    private void setDialectsOnLanguage(GlossaryLanguages glossaryLanguages,
                                       ItemContext itemContext,
                                       HtmlType html,
                                       String wordlistFullPath) {
        String listCode = html.getListCode();
        List<GlossaryDialect> dialects = createGlossaryDialectList(itemContext, html.getValue(), wordlistFullPath);
        switch (listCode) {
            case GlossaryConstants.ListCode.ARABIC : {
                glossaryLanguages.getArabic().getDialects().clear();
                glossaryLanguages.getArabic().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.BURMESE : {
                glossaryLanguages.getBurmese().getDialects().clear();
                glossaryLanguages.getBurmese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.CANTONESE : {
                glossaryLanguages.getCantonese().getDialects().clear();
                glossaryLanguages.getCantonese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.ENGLISH : {
                glossaryLanguages.getEnglish().getDialects().clear();
                glossaryLanguages.getEnglish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.FILIPINO : {
                glossaryLanguages.getFilipino().getDialects().clear();
                glossaryLanguages.getFilipino().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.HMONG : {
                glossaryLanguages.getHmong().getDialects().clear();
                glossaryLanguages.getHmong().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.KOREAN : {
                glossaryLanguages.getKorean().getDialects().clear();
                glossaryLanguages.getKorean().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.MANDARIN : {
                glossaryLanguages.getMandarin().getDialects().clear();
                glossaryLanguages.getMandarin().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.PUNJABI : {
                glossaryLanguages.getPunjabi().getDialects().clear();
                glossaryLanguages.getPunjabi().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.RUSSIAN : {
                glossaryLanguages.getRussian().getDialects().clear();
                glossaryLanguages.getRussian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SOMALI : {
                glossaryLanguages.getSomali().getDialects().clear();
                glossaryLanguages.getSomali().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SPANISH: {
                glossaryLanguages.getSpanish().getDialects().clear();
                glossaryLanguages.getSpanish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.UKRANIAN : {
                glossaryLanguages.getUkrainian().getDialects().clear();
                glossaryLanguages.getUkrainian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.VIETNAMESE : {
                glossaryLanguages.getVietnamese().getDialects().clear();
                glossaryLanguages.getVietnamese().getDialects().addAll(dialects);
                break;
            }
        }
    }


    /**
     * Creates a List<GlossaryDialect> based on the html content provided on import source file
     * @param itemContext
     * @param htmlContent
     * @param wordlistFullPath
     * @return
     */
    private List<GlossaryDialect> createGlossaryDialectList(ItemContext itemContext,
                                                            String htmlContent,
                                                            String wordlistFullPath) {
        List<GlossaryDialect> glossaryDialects = new ArrayList<>();

        final Document doc = Jsoup.parseBodyFragment(htmlContent);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements parTags = doc.getElementsByTag("p");

        // Expect only one wrapping <p> tag
        if (parTags.size() == 1) {
            String html = parTags.get(0).html();

            String[] dialectHtml = html.split(",");

            int dialectId = 0;

            for (String dialectString : dialectHtml) {
                final Document dialectDoc = Jsoup.parseBodyFragment(dialectString);
                dialectDoc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

                dialectId++;
                String dialectValue = dialectDoc.text();

                GlossaryDialect glossaryDialect = new GlossaryDialect();
                glossaryDialect.setId(Integer.toString(dialectId));
                glossaryDialect.setDefinition(dialectValue.trim());

                Elements aTags = dialectDoc.getElementsByTag("a");
                aTags.forEach(a -> {
                    if (a.attr("type").equals("audio/ogg") &&
                            StringUtils.isNotBlank(a.attr("href"))) {
                        addDialectAttachment(glossaryDialect, a.attr("href"), itemContext, wordlistFullPath);
                    }
                });

                glossaryDialects.add(glossaryDialect);
            }
        }

        return glossaryDialects;
    }

    /**
     * Adds Attachment object to Dialect.
     * Copies audio files to item's glossary folder
     * @param glossaryDialect
     * @param fileName
     * @param itemContext
     * @param wordListFullPath
     */
    private void addDialectAttachment(GlossaryDialect glossaryDialect,
                                      String fileName,
                                      ItemContext itemContext,
                                      String wordListFullPath) {

        glossaryDialect.getAudioFiles().add(createAttachment(fileName));

        File oggFile = new File(wordListFullPath + "/" + fileName);
        if (oggFile.exists()) {
            ImportFileUtil.copyFile(oggFile, itemContext.getLocalGlossaryFolderPath().toFile());
            File m4aFile =  new File(wordListFullPath + "/" + fileName.replace(".ogg", ".m4a"));
            if (m4aFile.exists()) {
                ImportFileUtil.copyFile(m4aFile, itemContext.getLocalGlossaryFolderPath().toFile());
            }
        }
    }

    /**
     * Ensures GlossaryLanguage contains the minimum amount of Dialects
     * @param glossaryLanguages
     */
    private void checkForDefaultDialects(GlossaryLanguages glossaryLanguages) {
        setMinimumDialectsForLanguage(glossaryLanguages.getArabic(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getBurmese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getCantonese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getEnglish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getFilipino(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getHmong(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getKorean(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getMandarin(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getPunjabi(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getRussian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSomali(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSpanish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getUkrainian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getVietnamese(), 1);
    }

    /**
     * Adds GlossaryDialect objects when minimum amount is not found
     * @param glossaryLanguage
     * @param minimumDialects
     */
    private void setMinimumDialectsForLanguage(GlossaryLanguage glossaryLanguage, int minimumDialects) {
        if (glossaryLanguage.getDialects().size() < minimumDialects) {
            for (int i=glossaryLanguage.getDialects().size(); i < minimumDialects; i++) {
                glossaryLanguage.getDialects().add(new GlossaryDialect());
            }
        }

    }

    /**
     * @param audio
     * @param audioId
     * @return
     */
    private ItemAudioResource createItemAudioResource(IatAudio audio, int audioId) {
        ItemAudioResource resource = new ItemAudioResource();
        resource.setId(Integer.toString(audioId));
        audio.getSources().forEach(source -> {
            resource.getProductionFiles().add(createAttachment(source));
        });
        return resource;
    }

    /**
     * @param image
     * @param imageId
     * @return
     */
    private ItemImageResource createItemImageResource(String image, int imageId) {
        ItemImageResource resource = new ItemImageResource();
        resource.setId(Integer.toString(imageId));
        resource.getProductionFile().setFileName(image);
        resource.getProductionFile().setUploadedDate(new Date());
        return resource;
    }

    /**
     * @param fileName
     * @return
     */
    private Attachment createAttachment(String fileName) {
        Attachment attach = new Attachment();
        attach.setFileName(fileName);
        attach.setUploadedDate(new Date());
        return attach;
    }

    /**
     * @param fileName
     * @param audioId
     * @return
     */
    private ItemCcAudioAssociation createItemCCAudioAssociation(String fileName, int audioId) {
        ItemCcAudioAssociation audioAssociation = new ItemCcAudioAssociation();
        audioAssociation.setCcFileName(fileName);
        audioAssociation.setAudioResourceId(Integer.toString(audioId));
        return audioAssociation;
    }

    /**
     * @param itemId
     * @param sourceItemFullPath
     * @return
     */
    private List<String> getCorrectResponsesFromQrx(String itemId,
                                                    String sourceItemFullPath,
                                                    String identifier) {
        List<String> values = new ArrayList<>();
        File qrxFile = ImportFileUtil.findItemFileInPath(
                sourceItemFullPath, String.format("item_%s_*.qrx", itemId));
        if (qrxFile != null && qrxFile.exists()) {
            String qrxContent = ImportFileUtil.readFileContents(qrxFile);
            final Document doc = Jsoup.parse(qrxContent, "", Parser.xmlParser());

            doc.getElementsByTag("responseDeclaration").forEach(respDeclaration -> {
                if (respDeclaration.attr("identifier").equals(identifier)) {
                    respDeclaration.getElementsByTag("value").forEach(value -> {
                        values.add(value.text());
                    });
                }
            });
        }
        return values;
    }

    /**
     * Used on all items except Stimulus
     *
     * @param content
     * @param accessibility
     * @return
     */
    private String processTTSTags(String content, ItemRelease.Item.Content.ApipAccessibility accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                    final Element ttsTag = doc.getElementById(
                        accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                    if (ttsTag != null) {
                        String tts = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation() == null ?
                            "" : accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation();
                        String ttsAlt = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate() == null ?
                            "" : accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate();

                        updateTTSSpanTag(ttsTag, tts, ttsAlt);
                    }
                }
            });
        }

        return doc.body().html();
    }

    private void updateTTSSpanTag(Element ttsTag, String tts, String ttsAlt) {
        ttsTag.addClass("iat-text2speech");
        // tts has a value
        if (StringUtils.isNotEmpty(tts)) {
            ttsTag.attr("data-iat-tts", tts);
            if (StringUtils.isEmpty(ttsAlt)) {
                ttsTag.attr("data-iat-tts-vi", tts);
            }
        }
        // ttsAlt has a value
        if (StringUtils.isNotEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
            if (StringUtils.isEmpty(tts)) {
                ttsTag.attr("data-iat-tts", ttsAlt);
            }
        }
        // None have values
        if (StringUtils.isEmpty(tts) && StringUtils.isEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts", tts);
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
        }
        ttsTag.removeAttr("id");
    }


    /**
     * Used only on Stimulus
     *
     * @param content
     * @param accessibility
     * @return
     */
    private String processTTSTags(String content, ItemRelease.Passage.Content.ApipAccessibility accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                    final Element ttsTag = doc.getElementById(
                        accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                    if (ttsTag != null) {
                        String tts = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation() == null ?
                            "" : accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation();
                        String ttsAlt = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate() == null ?
                            "" : accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate();

                        updateTTSSpanTag(ttsTag, tts, ttsAlt);
                    }
                }
            });
        }

        return doc.body().html();
    }


    /**
     * @param content
     * @param result
     * @return
     */
    private String processAudioTags(String content, IatMappingResult result) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("audio").forEach(audio -> {
            IatAudio iatAudio = new IatAudio();
            audio.getElementsByTag("source").forEach(source -> {
                iatAudio.getSources().add(source.attr("src"));
            });
            audio.getElementsByTag("track").forEach(track -> {
                iatAudio.setTrack(track.attr("src"));
            });
            int audioId = result.getAudioSources().size() + 1;
            iatAudio.setAudioId(audioId);
            result.getAudioSources().add(iatAudio);

            Element img = new Element("img");
            img.attr("title", "Audio Resource " + audioId);
            img.attr("data-iat-audio-resource-id", Integer.toString(audioId));
            img.attr("src", getAudioPlaceholderSrc(audioId));
            img.addClass("place-holder");

            audio.replaceWith(img);
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @param result
     * @return
     */
    private String processImageTags(String content, IatMappingResult result) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("img").forEach(image -> {
            IatImage iatImage = new IatImage();
            int imageId = result.getImageSources().size() + 1;
            iatImage.setImageId(imageId);
            iatImage.setSource(image.attr("src"));
            result.getImageSources().add(iatImage);

            Element img = new Element("img");
            img.attr("title", "Image Resource " + imageId);
            img.attr("data-iat-image-resource-id", Integer.toString(imageId));
            img.attr("src", getImagePlaceholderSrc(imageId));
            img.addClass("place-holder");

            image.replaceWith(img);
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @param result
     * @return
     */
    private String processAnchorTags(String content, IatMappingResult result) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("a").forEach(anchor -> {
            result.getFileSources().add(anchor.attr("href"));
        });

        return doc.body().html();
    }

//    /**
//     * @param content
//     * @return
//     */
//    private String processBoundaryTags(String content) {
//        final Document doc = Jsoup.parseBodyFragment(content);
//        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
//
//        doc.getElementsByAttribute("data-tag-boundary").forEach(Node::remove);
//
//        return doc.body().html();
//    }

    /**
     * @param content
     * @return
     */
    private String processTableTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("table").forEach(table -> {
            Attributes tableAtribs = table.attributes().clone();
            table.clearAttributes();
            table.attr("cellpadding", "1");
            table.attr("cellspacing", "1");
            table.attr("border", "1");

            if (StringUtils.isNotBlank(tableAtribs.get("style"))) {
                table.attr("style",
                    convertEmStyleToPixel(tableAtribs.get("style"), "width"));
            }

            table.getElementsByTag("colgroup").forEach(Node::remove);

            table.getElementsByTag("tr").forEach(tr -> {
                tr.getElementsByTag("td").forEach(Node::clearAttributes);
            });
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processListTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("ul").forEach(Node::clearAttributes);
        doc.getElementsByTag("ol").forEach(Node::clearAttributes);

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processHiddenDivTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("slides_config hidden").forEach(div -> {
            div.removeClass("hidden");
        });
        doc.getElementsByClass("slide hidden").forEach(div -> {
            div.removeClass("hidden");
        });

        return doc.body().html();
    }

    public String processGlossaryTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements startBoundaySpans = doc.getElementsByAttributeValue("data-tag-boundary", "start");
        Elements endBoudarySpans =  doc.getElementsByAttributeValue("data-tag-boundary", "end");

        startBoundaySpans.forEach(startSpan -> {
            String iatGlossSpan = String.format("<span class=\"iat-glossary-term\" data-iat-glossary-term-id=\"%s\">",
                    startSpan.attr("data-word-index"));
            startSpan.replaceWith(new TextNode(iatGlossSpan, null));
        });

        endBoudarySpans.forEach(endSpan -> {
            endSpan.replaceWith(new TextNode("</span>", null));
        });


        return doc.body().html()
                .replace("&lt;", "<")
                .replace("&gt;", ">");
    }

    /**
     * @param styleDef
     * @param styleName
     * @return
     */
    private String convertEmStyleToPixel(String styleDef, String styleName) {
        String saaifStyle = "";
        String value = getStyleValue(styleDef, styleName);
        if (StringUtils.isNotBlank(value)) {
            // TODO: Currently only supports en unit conversion
            if (value.contains("em")) {
                int val = (int) Float.parseFloat(value.replace("em", ""));
                saaifStyle = styleName + ":" + convertEmtoPixel(val) + ";";
            }
        }
        return saaifStyle;
    }

    /**
     * @param em
     * @return
     */
    private String convertEmtoPixel(int em) {
        try {
            final int pxUnit = em * PIXEL_TO_EM_CONVERSION_RATE;
            return String.format("%1d", pxUnit).concat("px");
        } catch (Exception ex) {
            return "";
        }
    }

    /**
     * Attempts to retrieve the the value of an inline style from a style definition string
     *
     * @param styleDef  e.g. "text-align:center; font-weight:bold; width: 500px; height: 200px"
     * @param styleName e.g. "width"
     * @return value of style or empty string if not found
     */
    private String getStyleValue(String styleDef, String styleName) {
        String styleVal = "";
        List<String> stylesList = Arrays.asList(styleDef.split(";"));
        for (String style : stylesList) {
            List<String> currStyle = Arrays.asList(style.split(":"));
            if (isNotEmpty(currStyle)) {
                if (currStyle.get(0).trim().equals(styleName)) {
                    styleVal = currStyle.get(1).trim();
                    break;
                }
            }
        }
        return styleVal;
    }

    /**
     * @param audioId
     * @return
     */
    private String getAudioPlaceholderSrc(int audioId) {
        return "/assets/ckeditor/plugins/iataudio/icons/audio-place-" +
            (audioId < 10 ? "0" : "") +
            audioId + ".png";
    }

    /**
     * @param imageId
     * @return
     */
    private String getImagePlaceholderSrc(int imageId) {
        return "/assets/ckeditor/plugins/iatimage/icons/image-place-" +
            (imageId < 10 ? "0" : "") +
            imageId + ".png";
    }

    /**
     * Returns an empty string if the argument is null.  If the argument is not null it is trimmed.
     *
     * @param str The value to trim.
     * @return Empty string if null passed in otherwise the argument is returned trimmed.
     */
    private String defaultString(String str) {
        return StringUtils.defaultString(str).trim();
    }

    /**
     *
     * @param saaifValue
     * @return
     */
    private String mapYandNtoYesandNo(String saaifValue) {
        return "Y".equalsIgnoreCase(saaifValue) ? "Yes" : "N".equalsIgnoreCase(saaifValue) ? "No" : "";
    }

    private String mapClaim2Category(String saaifValue) {
        return "C".equalsIgnoreCase(saaifValue) ? "Conventions" :
               "E".equalsIgnoreCase(saaifValue) ? "EvidenceElaboration" :
               "O".equalsIgnoreCase(saaifValue) ? "Organization" : "";

    }


    private String mapIatWritingPurpose(String saaifValue) {
        String value = "";
        if (saaifValue != null) {
            List<String> purposeValues = Arrays.asList("Narrative", "InformationalExplanatory", "OpinionArgumentative");
            value = purposeValues.stream()
                .filter(purpose -> purpose.toLowerCase().contains(saaifValue.toLowerCase()))
                .findAny()
                .orElse("");
        }
        return value;
    }

    private String mapIatSubject(String saaifValue) {
        String value = "";
        if (saaifValue.equalsIgnoreCase("math")) {
            value = "Math";
        } else if (saaifValue.equalsIgnoreCase("ela")) {
            value = "ELA";
        }
        return value;
    }

    private String convertInteractiveTagsToIat(String html) {
        final Document doc = Jsoup.parseBodyFragment(html);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("interaction selectable").forEach(span -> {
            span.clearAttributes();
            span.addClass("iat-htq-correct");
        });

        return doc.body().html();
    }
}
