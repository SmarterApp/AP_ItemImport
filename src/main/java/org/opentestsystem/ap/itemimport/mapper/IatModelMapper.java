package org.opentestsystem.ap.itemimport.mapper;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemAudioResource;
import org.opentestsystem.ap.common.model.ItemCcAudioAssociation;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.model.ItemMetadata;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.itemimport.model.IATAudio;
import org.opentestsystem.ap.itemimport.model.IATMappingResult;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.apache.commons.lang3.StringUtils.isNumeric;
import static org.apache.commons.lang3.math.NumberUtils.toInt;

@Slf4j
public abstract class IatModelMapper {
    abstract Item mapContent(Item item, ItemRelease release, ItemContext itemContext, String itemDirFullPath);
    abstract Item mapMetadata(Item item, SmarterAppMetadata metadata);

    private final int PIXEL_TO_EM_CONVERSION_RATE = 16;

    public final Item mapSaaifToIATModel(Item item,
                                         ItemRelease release,
                                         SmarterAppMetadata metadata,
                                         ItemContext itemContext,
                                         String itemDirFullPath) {

        item = mapContent(item, release, itemContext, itemDirFullPath);
        item = mapMetadata(item, metadata);

        return item;
    }

    public String mapRichTextContent(String content, ItemRelease.Item.Content.ApipAccessibility accessibility) {
        String iatContent = updateTTSTags(content, accessibility);
        iatContent = processBoundaryTags(iatContent);

        return iatContent;
    }

    /**
     *
     * @param content
     * @return
     */
    IATMappingResult mapRichTextContent(ItemRelease.Passage.Content content) {
        IATMappingResult result = new IATMappingResult();

        String iatContent = updateTTSTags(content.getStem(), content.getApipAccessibility());
        iatContent = processAudioTags(iatContent, result);
        iatContent = processImageTags(iatContent, result);

        iatContent = processBoundaryTags(iatContent);
        iatContent = processTableTags(iatContent);

        //TODO: process html table elements
        //TODO: process li elements
        //TODO: process p elements

        result.setContent(iatContent);

        return result;
    }

    /**
     *
     * @param audio
     * @param audioId
     * @return
     */
    ItemAudioResource createItemAudioResource(IATAudio audio, int audioId) {
        ItemAudioResource resource = new ItemAudioResource();
        resource.setId(Integer.toString(audioId));
        audio.getSources().forEach(source -> {
            resource.getProductionFiles().add(createAttachment(source));
        });
        return resource;
    }

    /**
     *
     * @param image
     * @param imageId
     * @return
     */
    ItemImageResource createItemImageResource(String image, int imageId) {
        ItemImageResource resource = new ItemImageResource();
        resource.setId(Integer.toString(imageId));
        resource.getProductionFile().setFileName(image);
        resource.getProductionFile().setUploadedDate(new Date());
        return  resource;
    }

    /**
     *
     * @param fileName
     * @return
     */
    Attachment createAttachment(String fileName) {
        Attachment attach = new Attachment();
        attach.setFileName(fileName);
        attach.setUploadedDate(new Date());
        return attach;
    }

    /**
     *
     * @param fileName
     * @param audioId
     * @return
     */
    ItemCcAudioAssociation createItemCCAudioAssociation(String fileName, int audioId) {
        ItemCcAudioAssociation audioAssociation = new ItemCcAudioAssociation();
        audioAssociation.setCcFileName(fileName);
        audioAssociation.setAudioResourceId(Integer.toString(audioId));
        return audioAssociation;
    }

    /**
     *
     * @param itemMetadata
     * @param smarterAppMetadata
     * @return
     */
    ItemMetadata mapItemMetadata(ItemMetadata itemMetadata, SmarterAppMetadata smarterAppMetadata) {
        // TODO: Validate each metadata value to confirm it is compatible with IAT
//        itemMetadata.setAccessibilityLanguageComplexity(smarterAppMetadata.getAccessibilityLanguageComplexity());
//        itemMetadata.setAlgebraDescriptor1("");
//        itemMetadata.setAlgebraDescriptor2("");
//        itemMetadata.setCalculator("");
//        itemMetadata.setClaim2Category("");
//        itemMetadata.setClaim2SubCategory("");
//        itemMetadata.setContentDomain("");
//        itemMetadata.setContentTaskModel("");
//        itemMetadata.setCopyrightHolder("");
//        itemMetadata.setCopyrightHolderOther("");
//        itemMetadata.setDepthOfKnowledge("");
//        itemMetadata.setGrade("");
//        itemMetadata.setItemPoint("");
//        itemMetadata.setKnowledgeDemands("");
//        itemMetadata.setLanguageFeatures("");
//        itemMetadata.setMaxGrade("");
//        itemMetadata.setMeaningPurpose("");
//        itemMetadata.setMinGrade("");
//        itemMetadata.setPassageName("");
//        itemMetadata.setPerformanceTask("");
//        itemMetadata.setPrimaryAssessmentTarget("");
//        itemMetadata.setPrimaryClaim("");
//        itemMetadata.setPrimaryCommonCoreStandard("");
//        itemMetadata.setPrimaryContentDomain("");
//        itemMetadata.setQuaternaryAssessmentTarget("");
//        itemMetadata.setQuaternaryClaim("");
//        itemMetadata.setQuaternaryCommonCoreStandard("");
//        itemMetadata.setQuaternaryAssessmentTarget("");
//        itemMetadata.setReadabilityFleschKincaid("");
//        itemMetadata.setReadabilityLexile("");
//        itemMetadata.setScoringEngine("");
//        itemMetadata.setScoringPoints("");
//        itemMetadata.setSecondaryAssessmentTarget("");
//        itemMetadata.setSecondaryClaim("");
//        itemMetadata.setSecondaryCommonCoreStandard("");
//        itemMetadata.setSecondaryContentDomain("");
//        itemMetadata.setStimulusFormat("");
//        itemMetadata.setStimulusLength("");
//        itemMetadata.setStructure("");
//        itemMetadata.setSubject("");
//        itemMetadata.setTertiaryAssessmentTarget("");
//        itemMetadata.setTertiaryClaim("");
//        itemMetadata.setTertiaryCommonCoreStandard("");
//        itemMetadata.setTertiaryContentDomain("");
//        itemMetadata.setTestCategory("");
//        itemMetadata.setWordCount("");
//        itemMetadata.setWritingPurpose("");

        return itemMetadata;
    }

    // User on all items except Stimulus

    /**
     *
     * @param content
     * @param accessibility
     * @return
     */
    private String updateTTSTags(String content, ItemRelease.Item.Content.ApipAccessibility accessibility) {
        // TODO: refactor function below to work with Passage and Item ApipAccessibility
        return content;
    }

    // Used only on Stimulus
    /**
     *
     * @param content
     * @param accessibility
     * @return
     */
    private String updateTTSTags(String content, ItemRelease.Passage.Content.ApipAccessibility accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                    final Element ttsTag = doc.getElementById(
                            accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                    if (ttsTag != null) {
                        String tts = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation();
                        String ttsAlt = accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate();

                        if (!tts.equals("") || !ttsAlt.equals("")) {
                            ttsTag.addClass("iat-text2speech");
                            if (!tts.equals("")) {
                                ttsTag.attr("data-iat-tts", tts);
                            }
                            if (!ttsAlt.equals("")) {
                                ttsTag.attr("data-iat-tts-vi", ttsAlt);
                            }
                            ttsTag.removeAttr("id");
                        }
                    }
                }
            });
        }

        return doc.body().html();
    }

    /**
     *
     * @param content
     * @param result
     * @return
     */
    private String processAudioTags(String content, IATMappingResult result) {
        List<IATAudio> iatAudios = new ArrayList<>();

        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("audio").forEach(audio -> {
            IATAudio iatAudio = new IATAudio();
            audio.getElementsByTag("source").forEach(source -> {
                iatAudio.getSources().add(source.attr("src"));
            });
            audio.getElementsByTag("track").forEach(track -> {
                iatAudio.setTrack(track.attr("src"));
            });
            iatAudios.add(iatAudio);

            Element img = new Element("img");
            int elementId = iatAudios.size();
            img.attr("title", "Audio Resource " + elementId);
            img.attr("data-iat-audio-resource-id", Integer.toString(elementId));
            //TODO: Call function that returns src value
            img.attr("src", "/assets/ckeditor/plugins/iataudio/icons/audio-place-0" + elementId +  ".png");
            img.addClass("place-holder");

            audio.replaceWith(img);
        });

        result.setAudioList(iatAudios);

        return doc.body().html();
    }

    /**
     *
     * @param content
     * @param result
     * @return
     */
    private String processImageTags(String content, IATMappingResult result) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        AtomicInteger imageId = new AtomicInteger(1);
        doc.getElementsByTag("img").forEach(image -> {
            Element img = new Element("img");
            img.attr("title", "Image Resource " + imageId);
            img.attr("data-iat-image-resource-id", imageId.toString());
            //TODO: Call function that returns src value
            img.attr("src", "/assets/ckeditor/plugins/iataudio/icons/audio-place-0" + imageId +  ".png");
            img.addClass("place-holder");

            image.replaceWith(img);

            result.getImageList().add(image.attr("src"));
        });

        return doc.body().html();
    }

    /**
     *
     * @param content
     * @return
     */
    private String processBoundaryTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByAttribute("data-tag-boundary").forEach(Node::remove);

        return doc.body().html();
    }

    /**
     *
     * @param content
     * @return
     */
    private String processTableTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("table").forEach(table -> {
            Attributes tableAtribs = table.attributes().clone();
            table.clearAttributes();
            table.attr("cellpadding", "1");
            table.attr("cellspacing", "1");
            table.attr("border", "1");

            if (StringUtils.isNotBlank(tableAtribs.get("style"))) {
                table.attr("style",
                        convertEmStyleToPixel(tableAtribs.get("style"), "width"));
            }

            table.getElementsByTag("colgroup").forEach(Node::remove);

            table.getElementsByTag("tr").forEach(tr -> {
                tr.getElementsByTag("td").forEach(Node::clearAttributes);
            });
        });

        return doc.body().html();
    }

    /**
     *
     * @param styleDef
     * @param styleName
     * @return
     */
    private String convertEmStyleToPixel(String styleDef, String styleName) {
        String saaifStyle = "";
        String value = getStyleValue(styleDef, styleName);
        if (StringUtils.isNotBlank(value)) {
            // TODO: Currently only supports en unit conversion
            if (value.contains("em")) {
                int val = (int) Float.parseFloat(value.replace("em", ""));
                saaifStyle = styleName + ":" + convertEmtoPixel(val) + ";";
            }
        }
        return saaifStyle;
    }

    /**
     *
     * @param em
     * @return
     */
    private String convertEmtoPixel(int em) {
        try {
            final int pxUnit = em * PIXEL_TO_EM_CONVERSION_RATE ;
            return String.format("%1d", pxUnit).concat("px");
        } catch (Exception ex) {
            return "";
        }
    }

    /**
     * Attempts to retrieve the the value of an inline style from a style definition string
     *
     * @param styleDef  e.g. "text-align:center; font-weight:bold; width: 500px; height: 200px"
     * @param styleName e.g. "width"
     * @return value of style or empty string if not found
     */
    private String getStyleValue(String styleDef, String styleName) {
        String styleVal = "";
        List<String> stylesList = Arrays.asList(styleDef.split(";"));
        for (String style : stylesList) {
            List<String> currStyle = Arrays.asList(style.split(":"));
            if (isNotEmpty(currStyle)) {
                if (currStyle.get(0).trim().equals(styleName)) {
                    styleVal = currStyle.get(1).trim();
                    break;
                }
            }
        }
        return styleVal;
    }
}
