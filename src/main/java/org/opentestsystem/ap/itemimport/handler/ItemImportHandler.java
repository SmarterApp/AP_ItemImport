package org.opentestsystem.ap.itemimport.handler;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemFactory;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.itemimport.config.ApplicationDependencyProvider;
import org.opentestsystem.ap.itemimport.config.ApplicationProps;
import org.opentestsystem.ap.itemimport.mapper.IatModelMapper;
import org.opentestsystem.ap.itemimport.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.itemimport.model.IatImportConstants;
import org.opentestsystem.ap.itemimport.model.ItemProps;
import org.opentestsystem.ap.itemimport.model.report.ImportResult;
import org.opentestsystem.ap.itemimport.util.ImportFileUtil;
import org.opentestsystem.ap.itemimport.util.ImportHandlerUtil;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Objects;
import java.util.Optional;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;


@Slf4j
@Component
public class ItemImportHandler {

    private final ApplicationProps applicationProps;

    private final AppAssembler appAssembler;

    private final IatModelMapperFactory iatModelMapperFactory;

    private final ItemManager itemManager;

    private final GitLabSyncManager itemBankSyncManager;

    private final ItemBankProperties itemBankProperties;

    private final ItemRepository itemRepository;

    private final DataStoreAttachmentManager attachmentManager;

    private final ItemFactory itemFactory;

    public ItemImportHandler(final ApplicationDependencyProvider dependencyProvider,
                             final IatModelMapperFactory iatModelMapperFactory) {
        this.applicationProps = dependencyProvider.getApplicationProps();
        this.appAssembler = dependencyProvider.getAppAssembler();
        this.iatModelMapperFactory = iatModelMapperFactory;
        this.itemManager = dependencyProvider.getItemManager();
        this.itemBankSyncManager = dependencyProvider.getItemBankSyncManager();
        this.itemBankProperties = dependencyProvider.getItemBankProperties();
        this.itemRepository = dependencyProvider.getItemRepository();
        this.attachmentManager = dependencyProvider.getDataStoreAttachmentManager();
        this.itemFactory = new ItemFactory();
    }

    /**
     * Main item import method. Validates all item files dependencies exist prior to processing the import
     *
     * @param importData Comma delimited value of directory name and TIMS workflow status. e.g.
     *                   item-200-9757,Operational
     * @return
     */
    public ImportResult importItem(String importData) {
        Path localRepositoryPath = null;
        ImportResult importResult = new ImportResult();

        String[] importValues = importData.split(",");
        if (importValues.length == 3) {
            String itemDirName = importValues[0];
            String itsWorkflowStatus = importValues[1];
            String timsWorkflowStatus = importValues[2];

            final String sourceRootDirectory = itemDirName.toLowerCase().startsWith("item")
                ? applicationProps.getItemSourceDir()
                : applicationProps.getStimuliSourceDir();

            try {
                final File sourceDir = ImportFileUtil.getSourceDirectoryPath(sourceRootDirectory, itemDirName);

                // Find the main item file in the source location
                final File itemFile =
                    ImportFileUtil.findItemFileInPath(sourceDir.toString(), itemDirName.toLowerCase() + ".xml");

                //Find the metadata file in the source location
                final File metaFile = new File(sourceDir.toString() + "/metadata.xml");

                if (itemFile != null && metaFile.exists()) {
                    final ItemRelease itemRelease = this.appAssembler.getSaaifAssembler()
                        .readXmlFromFile(itemFile.toPath());

                    final SmarterAppMetadata itemMetadata = this.appAssembler.getSaaifAssembler()
                        .getMetadataAssembler().readXmlFromFile(metaFile.toPath());

                    // Here we set as much of the item props as we can.
                    // The import.zip update and import/re-import need these properties.
                    final ItemProps itemProps = ImportHandlerUtil.loadItemProps(itemDirName, itemRelease);
                    itemProps.setSourceDir(sourceDir);
                    itemProps.setItemRelease(itemRelease);
                    itemProps.setItemMetadata(itemMetadata);
                    itemProps.setItsWorkflowStatus(itsWorkflowStatus);
                    itemProps.setImportWorkflowStatus(timsWorkflowStatus);

                    localRepositoryPath = this.generateLocalItemPath(itemProps.getImportItemId());
                    itemProps.setLocalRepositoryPath(localRepositoryPath);

                    // set the glossary properties
                    this.setItemGlossaryProperties(itemProps);

                    // set the result with these properties now that they are known
                    importResult.setItemId(itemProps.getItemId());
                    importResult.setImportedItemId(itemProps.getImportItemId());
                    importResult.setImportedItemType(itemProps.getItemType());

                    // the item has to exist in the data store and the 'updateImportZipOnly' has to be true
                    if (this.isUpdateImportZipOnly(itemProps.getImportItemId())) {
                        this.updateImportZip(itemProps, importResult);
                    } else {
                        // 'deleteIfExists' when false throws an exception if the item exist in the data store
                        this.importOrDeleteReimport(itemProps, importResult);
                    }
                } else {
                    importResult.setItemId(itemDirName);
                    importResult.setStatus(IatImportConstants.STATUS_ERROR);
                    String error = format("Item or Metadata files not found for: %s", itemDirName);
                    importResult.getErrorMessages().add(error);
                    log.error(error);
                }
            } catch (Exception e) {
                importResult.setItemId(itemDirName);
                importResult.setStatus(IatImportConstants.STATUS_ERROR);

                String error = format("Error processing import: %s %s %s",
                    itemDirName,
                    e.getMessage(), (Objects.nonNull(e.getCause()) ? e.getCause().getMessage() : StringUtils.EMPTY));

                importResult.getErrorMessages().add(error.trim());
                log.error(error);
            } finally {
                this.deleteDirectory(localRepositoryPath);
            }

        } else {
            importResult.setItemId(importData);
            importResult.setStatus(IatImportConstants.STATUS_ERROR);
            importResult.getErrorMessages()
                .add(
                    "Invalid data found in import file. Expected comma delimited values (item id, its status, tims status)");
            log.error(
                "Invalid data found in import file. Expected comma delimited values (item id, its status, tims status)");
        }

        return importResult;
    }

    /**
     * Imports the item because it has never been imported or because it will be re-imported.
     *
     * @param itemProps
     * @param importResult
     * @throws Exception
     */
    private void importOrDeleteReimport(ItemProps itemProps, ImportResult importResult) throws Exception {
        log.info("item {}: import / re-import", itemProps.getItemId());

        // throws if the item exists and the 'deleteIfExists' flag is false
        ImportHandlerUtil.validateImportItemExistsInRepository(
            itemManager, applicationProps, itemProps.getImportItemId());

        // does not throw
        ImportHandlerUtil.validateAssociatedItemsExistInRepository(
            itemManager, itemProps, importResult);

        processImport(itemProps, importResult);
    }

    /**
     * Calls mapping and data persistence operations
     *
     * @param itemProps
     * @param importResult
     * @return
     */
    private void processImport(ItemProps itemProps, ImportResult importResult) throws IOException {
        final IatModelMapper mapper = iatModelMapperFactory.newModelMapper(itemProps.getItemType());

        // check the reimport flag as it signals to delete an already existing item however, if the item has not been
        // imported (e.g. does not exist in the data store) then our only choice is to import it
        if (applicationProps.isDeleteIfExists()) {
            if (this.itemManager.doesItemExist(itemProps.getImportItemId())) {
                if (!applicationProps.isDryRun()) {
                    // delete from the data store and gitlab, we are not deleting from S3
                    try {
                        String legacyId = itemRepository.findLegacyItemId(itemProps.getImportItemId());
                        this.itemManager.deleteItem(
                                itemBankProperties.getSystemUser(), legacyId, true);
                    } catch (ResourceNotFoundException rnfe) {
                        log.info(String.format("Unable to delete from GitLabManager or DataStoreManager: %s", itemProps.getImportItemId()), rnfe);
                    }
                }
                String logMessage = format("Deleted project %s prior to import", itemProps.getImportItemId());
                importResult.getInfoMessages().add(logMessage);
            }
        }

        final Item item = mapper.mapSaaifToIATModel(
            itemProps,
            itemFactory.newItem(itemProps.getImportItemId(), itemProps.getItemType()),
            itemProps.getItemRelease(),
            itemProps.getItemMetadata(),
            itemProps.getWordListRelease(),
            itemProps.getWordListDirectory(),
            itemProps.getLocalRepositoryPath(),
            itemProps.getSourceDir().toString(),
            importResult);

        ImportHandlerUtil.createImportZipFile(itemProps,
            itemProps.getWordListDirectory(),
            itemProps.getSourceDir().toString(),
            itemProps.getLocalRepositoryPath());

        final String commitMessage = ImportHandlerUtil.getImportCommitMessage(itemProps, applicationProps.isDryRun());

        if (!applicationProps.isDryRun()) {
            itemManager.createItem(
                itemBankProperties.getSystemUser(),
                itemProps.getImportItemId(),
                itemProps.getItemType().toLowerCase(),
                applicationProps.getItemCreateMessage(),
                true,
                item.getWorkflow().getWorkflowStatusCode());

            itemBankSyncManager.syncAttachmentsToDataStore(
                itemProps.getImportItemId(), BRANCH_MASTER, itemProps.getLocalRepositoryPath());

            itemManager.commitItem(itemBankProperties.getSystemUser(), item, commitMessage);
        }

        importResult.setCommitMessage(commitMessage);
        importResult.setStatus(IatImportConstants.STATUS_SUCCESS);

        log.info(commitMessage);
    }

    private void updateImportZip(ItemProps itemProps, ImportResult importResult) throws IOException {
        log.info("Update import.zip for item " + itemProps.getImportItemId());

        final String commitMessage = "Import update: overwrite import.zip";

        if (!applicationProps.isDryRun()) {
            final GitClient gitClient = itemRepository.cloneRemoteRepository(
                itemBankProperties.getSystemUser(), itemProps.getImportItemId());

            final Optional<Path> importZipFile = ImportHandlerUtil.createImportZipFile(itemProps,
                itemProps.getWordListDirectory(),
                itemProps.getSourceDir().toString(),
                gitClient.getLocalRepositoryPath());


            // first write the zip to S3
            importZipFile.ifPresent(filePath ->
                this.attachmentManager.saveAttachment(
                    itemProps.getImportItemId(),
                    BRANCH_MASTER,
                    filePath.toFile().getName(),
                    filePath)
            );

            // then commit it to GitLab
            gitClient.pushAll(commitMessage);

            importResult.setCommitMessage(commitMessage);

            log.info(commitMessage);

            // delete removes the parent of the local repo path, make sure that is what we want,
            // specifically make sure the clone of the repo has randomizeItemClone = true which it does by default
            this.deleteDirectory(gitClient.getLocalRepositoryPath());
        } else {
            ImportHandlerUtil.createImportZipFile(itemProps,
                itemProps.getWordListDirectory(),
                itemProps.getSourceDir().toString(),
                itemProps.getLocalRepositoryPath());

            importResult.setCommitMessage(commitMessage + " (dry-run)");

            log.info(commitMessage + " (dry-run)");
        }

        importResult.setStatus(IatImportConstants.STATUS_SUCCESS);
    }

    private void setItemGlossaryProperties(ItemProps itemProps) throws Exception {
        // Validate wordlist if item has one as a resource
        if (StringUtils.isNotBlank(itemProps.getWordlistId())) {
            itemProps.setWordListDirectory(
                ImportFileUtil.getWordListDirectory(applicationProps, itemProps));
            itemProps.setWordListRelease(
                ImportFileUtil.getWordListRelease(
                    itemProps.getWordListDirectory(), itemProps.getWordlistId(), appAssembler));
        }
    }

    private Path generateLocalItemPath(String importItemId) {
        Path localRepositoryPath = ImportFileUtil.generateLocalItemPath(
            applicationProps.getLocalBaseDir(),
            RandomStringUtils.randomAlphabetic(8),
            importItemId);
        localRepositoryPath.toFile().mkdirs();
        return localRepositoryPath;
    }

    private void deleteDirectory(Path directory) {
        if (Objects.nonNull(directory)) {
            try {
                ImportFileUtil.deleteDirectory(directory.toFile().getParentFile());
            } catch (IOException e) {
                log.error("Failed to delete directory " + directory.toFile(), e);
            }
        }
    }

    /**
     * Returns true if the 'updateImportZipOnly' is true and the item exists in the data store, false otherwise.
     *
     * @param importItemId
     * @return
     */
    private boolean isUpdateImportZipOnly(String importItemId) {
        return ImportHandlerUtil.isUpdateItemImportZipOnly(itemManager, applicationProps, importItemId);
    }
}
