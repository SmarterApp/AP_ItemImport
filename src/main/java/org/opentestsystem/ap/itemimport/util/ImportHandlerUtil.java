package org.opentestsystem.ap.itemimport.util;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.mapper.model.ItemMappingResult;
import org.opentestsystem.ap.common.saaif.mapper.model.ItemProps;
import org.opentestsystem.ap.itemimport.config.ApplicationProps;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Slf4j
@Component
public class ImportHandlerUtil {

    private static final String BANKKEY_200 = "200";
    private static final String BANKKEY_187 = "187";

    private static final String PREFIX_17 = "17";
    private static final String PREFIX_18 = "18";
    private static final String PREFIX_19 = "19";

    private static final List<String> VALID_BANKKEY;

    static {
        VALID_BANKKEY = new ArrayList<>();
        VALID_BANKKEY.add(BANKKEY_187);
        VALID_BANKKEY.add(BANKKEY_200);
    }

    private enum ID_TYPE {
        STIMULUS,
        ITEM
    }

    /**
     * Creates a Zip file containing all files used while importing an item.
     *
     * @param itemProps
     * @param wordListFullPath
     * @param sourceItemFullPath
     * @param destinationPath
     * @return The path to the import zip.
     * @throws IOException
     */
    public static Optional<Path> createImportZipFile(ItemProps itemProps,
                                                     String wordListFullPath,
                                                     String sourceItemFullPath,
                                                     Path destinationPath) throws IOException {
        Optional<Path> zipPath = Optional.empty();
        File tempZipDir = destinationPath.resolve("tempZip").toFile();
        if (tempZipDir.mkdirs()) {
            // Copy main item source directory to tempZip directory
            File sourceDir = new File(sourceItemFullPath);
            ImportFileUtil.copyDirectoryToDirectory(sourceDir, tempZipDir);

            // Copy Wordlist directory to tempZip directory
            if (StringUtils.isNotBlank(itemProps.getWordlistId())) {
                File wordlistDir = new File(wordListFullPath);
                if (wordlistDir.exists() && sourceDir.exists()) {
                    ImportFileUtil.copyDirectoryToDirectory(wordlistDir, tempZipDir);
                }
            }

            // Create a Zip file containing all source files
            ImportFileUtil.zipDirectory(tempZipDir.toString(),
                destinationPath.toString(),
                ImportFileUtil.IMPORT_ZIP_FILENAME);

            // Remove tempZip directory
            if (tempZipDir.exists()) {
                ImportFileUtil.deleteDirectory(tempZipDir);
            }
            zipPath = Optional.of(destinationPath.resolve(ImportFileUtil.IMPORT_ZIP_FILENAME));
        }
        return zipPath;
    }

    /**
     * Hydrates an ItemProps object with ids to be used during an item import
     *
     * @param release
     * @return
     * @throws Exception
     */
    public static ItemProps loadItemProps(String itemDirName, ItemRelease release) throws Exception {
        final String HTQ = "htq";
        final String HT = "ht";
        ItemProps itemProps = new ItemProps();

        if (release.getPassage() != null) {
            itemProps.setItemId(release.getPassage().getId());
            itemProps.setBankKey(release.getPassage().getBankkey());
            itemProps.setItemType(ItemConstants.ItemType.TYPE_STIM);

            setWordListValues(itemDirName, release, itemProps);

            itemProps.setImportItemId(getImportId(ID_TYPE.STIMULUS,
                release.getPassage().getId(),
                release.getPassage().getBankkey()));
        }
        if (release.getItem() != null) {
            itemProps.setItemId(release.getItem().getId());
            itemProps.setBankKey(release.getItem().getBankkey());
            itemProps.setItemType(release.getItem().getFormat().toLowerCase());
            if (itemProps.getItemType().equalsIgnoreCase(HTQ)
                || itemProps.getItemType().equalsIgnoreCase(HT)) {
                itemProps.setItemType(ImportHandlerUtil.getIatHtqType(release));
            }
            if (itemProps.getItemType().equals("er")) {
                itemProps.setItemType(ItemConstants.ItemType.TYPE_SA);
            }
            itemProps.setAssociatedPassage(release.getItem().getAssociatedpassage());
            itemProps.setTutorialId(release.getItem().getTutorial().getId());

            setWordListValues(itemDirName, release, itemProps);

            itemProps.setImportItemId(getImportId(ID_TYPE.ITEM,
                release.getItem().getId(),
                release.getItem().getBankkey()));

            itemProps.setImportAssociatedPassage(getImportId(ID_TYPE.STIMULUS,
                release.getItem().getAssociatedpassage(),
                release.getItem().getBankkey()));

            itemProps.setImportTutorialId(getImportId(ID_TYPE.ITEM,
                release.getItem().getTutorial().getId(),
                release.getItem().getBankkey()));
        }

        if (itemProps.getItemId() == null || itemProps.getBankKey() == null || itemProps.getItemType() == null) {
            throw new Exception(
                String.format("Unable to read item id, bank key or item type for item: %s", itemDirName));
        }

        return itemProps;
    }

    /**
     * Check if Associated Passage or Tutorial exist in data repository
     *
     * @param itemManager
     * @param itemProps
     * @param itemMappingResult
     */
    public static void validateAssociatedItemsExistInRepository(ItemManager itemManager,
                                                                ItemProps itemProps,
                                                                ItemMappingResult itemMappingResult) {
        if (!itemProps.getItemType().equals(ItemConstants.ItemType.TYPE_STIM) &&
            !itemProps.getItemType().equals(ItemConstants.ItemType.TYPE_TUT)) {

            if (StringUtils.isNotBlank(itemProps.getImportAssociatedPassage())) {
                if (!itemManager.doesItemExist(itemProps.getImportAssociatedPassage())) {
                    itemMappingResult.getErrorMessages().add(
                        String.format(
                            "Associated Passage %s was not found in Item Bank. Item %s will be imported with no associated Passage",
                            itemProps.getImportAssociatedPassage(),
                            itemProps.getImportItemId()));
                    itemProps.setImportAssociatedPassage("");
                }
            }
            if (StringUtils.isNotBlank(itemProps.getImportTutorialId())) {
                if (!itemManager.doesItemExist(itemProps.getImportTutorialId())) {
                    itemMappingResult.getErrorMessages().add(
                        String.format(
                            "Associated Tutorial %s was not found in Item Bank. Item %s will be imported with no associated Tutorial",
                            itemProps.getImportTutorialId(),
                            itemProps.getImportItemId()));
                    itemProps.setImportTutorialId("");
                }
            }
        }
    }

    /**
     * If the 'deleteIfExists' flag is false and the item exists in the data store then throw exception.
     *
     * @param itemManager
     * @param applicationProps
     * @param itemId
     * @throws Exception
     */
    public static void validateImportItemExistsInRepository(ItemManager itemManager,
                                                            ApplicationProps applicationProps,
                                                            String itemId) throws Exception {
        if (!applicationProps.isDeleteIfExists() && itemManager.doesItemExist(itemId)) {
            String message = String
                .format("Item %s already exists in repository. This item will not be imported", itemId);
            log.error(message);
            throw new Exception(message);
        }
    }

    /**
     * If the 'updateImportZipOnly' is true and the item exists in the data store then true is returned.  False
     * otherwise.
     *
     * @param itemManager
     * @param applicationProps
     * @param itemId
     * @return
     */
    public static boolean isUpdateItemImportZipOnly(ItemManager itemManager,
                                                    ApplicationProps applicationProps,
                                                    String itemId) {
        return applicationProps.isUpdateImportZipOnly() && itemManager.doesItemExist(itemId);
    }

    /**
     * Map htq item type to TIMS htqs or htqo
     *
     * @param release
     * @return
     */
    public static String getIatHtqType(ItemRelease release) {
        String iatHtqType = "";
        for (ItemRelease.Item.Content content : release.getItem().getContent()) {
            if (content.getLanguage().equals(ItemConstants.ItemLanguage.LANG_ENU)) {
                if (content.getStem().contains("interaction selectable")) {
                    iatHtqType = ItemConstants.ItemType.TYPE_HTQS;
                    break;
                } else {
                    iatHtqType = ItemConstants.ItemType.TYPE_HTQO;
                    break;
                }
            }
        }
        return iatHtqType;
    }

    /**
     * Gets commit message for imported item
     *
     * @param itemProps
     * @return
     */
    public static String getImportCommitMessage(ItemProps itemProps, boolean isDryRun) {
        return String.format("Imported%sITS %s %s from bank %s, ITS workflow status: %s, TIMS workflow status: %s",
            isDryRun ? " (dry-run mode) " : " ",
            itemProps.getItemType().equals(ItemConstants.ItemType.TYPE_STIM) ? "Stim" : "Item",
            StringUtils.defaultString(itemProps.getItemId()).trim(),
            StringUtils.defaultString(itemProps.getBankKey()).trim(),
            StringUtils.defaultString(itemProps.getItsWorkflowStatus()).trim(),
            StringUtils.defaultString(itemProps.getImportWorkflowStatus()));
    }

    /**
     * @param itemProps
     * @return
     */
    public static String getWordlistCommitMessage(ItemProps itemProps, boolean isDryRun) {
        return String.format("Imported%sglossary terms to %s %s",
            isDryRun ? " (dry-run mode) " : " ",
            itemProps.getItemType().equals(ItemConstants.ItemType.TYPE_STIM) ? "Stim" : "Item",
            StringUtils.defaultString(itemProps.getImportItemId()).trim());
    }

    /**
     * Gets word list id of present on item
     *
     * @param release
     * @return
     */
    private static void setWordListValues(String itemDirName,
                                          ItemRelease release,
                                          ItemProps itemProps) {
        String wlId = "";
        String wlBankKey = "";
        if (release.getPassage() != null
            && release.getPassage().getResourceslist() != null
            && release.getPassage().getResourceslist().getResource() != null
            && release.getPassage().getResourceslist().getResource().size() == 1) {
            wlId = release.getPassage().getResourceslist().getResource().get(0).getId();
            wlBankKey = release.getPassage().getResourceslist().getResource().get(0).getBankkey();
        } else if (release.getItem() != null
            && release.getItem().getResourceslist() != null
            && release.getItem().getResourceslist().getResource() != null
            && release.getItem().getResourceslist().getResource().size() == 1) {
            wlId = release.getItem().getResourceslist().getResource().get(0).getId();
            wlBankKey = release.getItem().getResourceslist().getResource().get(0).getBankkey();

        }
        if (StringUtils.isNotBlank(wlId) && StringUtils.isNotBlank(wlBankKey)) {
            itemProps.setWordlistId(String.format("item-%s-%s", wlBankKey, wlId));
            String wordListDirName = itemProps.getWordlistId();
            if (itemDirName.startsWith("Item") || itemDirName.startsWith("Stim")) {
                wordListDirName = itemProps.getWordlistId().replace("item", "Item");
            }
            itemProps.setWordListDirName(wordListDirName);
        }
    }

    /**
     * Maps source item id to id to be used in IAT
     *
     * @param idType
     * @param itemId
     * @param bankKey
     * @return
     * @throws Exception
     */
    private static String getImportId(ID_TYPE idType, String itemId, String bankKey) throws Exception {
        String importId = "";
        if (itemId == null) {
            return null;
        }

        if (VALID_BANKKEY.contains(bankKey)) {
            if (ID_TYPE.ITEM.equals(idType)) {
                if (bankKey.equals(BANKKEY_200)) {
                    importId = itemId;
                } else if (bankKey.equals(BANKKEY_187)) {
                    importId = PREFIX_18 + StringUtils.leftPad(itemId, 4, "0");
                }
            } else if (ID_TYPE.STIMULUS.equals(idType)) {
                if (bankKey.equals(BANKKEY_200)) {
                    importId = PREFIX_17 + StringUtils.leftPad(itemId, 4, "0");
                } else if (bankKey.equals(BANKKEY_187)) {
                    importId = PREFIX_19 + StringUtils.leftPad(itemId, 4, "0");
                }
            }
        } else {
            throw new Exception(
                String.format("Unsupported bankkey value %s found while importing Item %s", bankKey, itemId));
        }
        return importId;
    }
}
