package org.opentestsystem.ap.itemimport.gitlab;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabItemManager;
import org.opentestsystem.ap.common.model.sync.SyncItemResult;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;

import static java.util.stream.Collectors.toList;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_CREATE;

/**
 * Migrates items from GitLab to the data store.
 */
@Slf4j
@Component
public class GitLabSyncManager {

    private static final boolean NOT_EDITING = false;

    private static final boolean YES_EDITING = true;

    private final ItemBankProperties itemBankProperties;

    private final GitLabItemManager gitLabItemManager;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    public GitLabSyncManager(ItemBankProperties itemBankProperties,
                             GitLabItemManager gitLabItemManager,
                             DataStoreDataManager dataStoreDataManager,
                             DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.itemBankProperties = itemBankProperties;
        this.gitLabItemManager = gitLabItemManager;
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
    }

    // ------------------------------------------------------------------------

    /**
     * Stores files in the given path to the data store.  The branch is the folder name to store the files in.  The
     * attachments path is expected to be a directory.
     *
     * @param itemId          The item
     * @param branch          The branch
     * @param attachmentsPath The directory holding the item attachments to store.
     * @return The results of syncing the attachments.
     */
    public List<SyncItemResult.Attachments> syncAttachmentsToDataStore(String itemId,
                                                                       String branch,
                                                                       Path attachmentsPath) {
        List<String> filesToCopy = listFilesInFolder(attachmentsPath);
        return syncAttachmentsToDataStore(itemId, branch, attachmentsPath, filesToCopy);
    }

    private List<SyncItemResult.Attachments> syncAttachmentsToDataStore(String itemId,
                                                                        String branch,
                                                                        Path attachmentsPath,
                                                                        Collection<String> attachmentFiles) {
        log.info("Syncing attachments for item {} branch {}", itemId, branch);

        String branchName = SECTION_CREATE.equalsIgnoreCase(branch) ? BRANCH_MASTER : branch;

        return attachmentFiles.stream()
            .map(fileName -> {
                SyncItemResult.Attachments result = new SyncItemResult.Attachments(fileName);
                try {
                    boolean success = this.syncAttachment(
                        itemId, branchName, fileName, attachmentsPath.resolve(fileName));

                    result.setSuccess(success);

                    if (!success) {
                        result.setMessage("Attachment already exists in data store");
                    }
                } catch (Exception e) {
                    result.setMessage(ExceptionUtils.getRootCauseMessage(e));
                }
                return result;
            })
            .collect(toList());
    }

    // ------------------------------------------------------------------------

    private boolean syncAttachment(String itemId, String branch, String relativeFileName, Path filePath) {
        log.info("Syncing attachment for item {} branch {} ", itemId, branch);
        this.dataStoreAttachmentManager.saveAttachment(itemId, branch, relativeFileName, filePath);
        return true;
    }

    /**
     * Lists the files in the folder.  Files nested in folders are returned.  Folders are not returned.  For example
     * <ul>
     * <li>file1</li>
     * <li>file2</li>
     * <li>general-attachments/file3</li>
     * <li>general-attachments/file4</li>
     * <li>glossary/file5</li>
     * <li>file6</li>
     * </ul>
     * <p>
     * Notice the file names are a path relative to the folder.
     *
     * @param folder The folder to find the files for.
     * @return A list of relative file names existing in the given folder.
     */
    private List<String> listFilesInFolder(Path folder) {
        try {
            return Files.walk(folder)
                .filter(Files::isRegularFile)
                .map(path -> folder.relativize(path).toString())
                .sorted()
                .collect(toList());
        } catch (IOException e) {
            throw new SystemException("Error listing files in path " + folder.toString(), e);
        }
    }
}
